# -*- coding: utf-8 -*-
"""Task_2_Clustering - Copy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FoO5pQqICDrnfh9rhiHjJ4mD7yk_0Ma9

# Task 2: Clustering

In this task you are required to apply a machine learning algorithm to the dataset `country_data.csv` which can be downloaded from the assignment task on canvas.
This data set contains information about a countries child mortality, exports, health spending, etc. <br>

Use **clustering** to investigate this data set. After clustering the data you should analyse the results and discuss what can be concluded by the clusters. <br> <br>
Ideas to consider when completing this task:
- Is there a way of visualising the clusters?
- Can you make any conclusions about the clustering?
- Include as many features as you can. Does the clustering change?
- What advice would you give, in the context of the data, based on the clustering?

## Data Preparation

#### Importing libraries
"""

# data analysis
import pandas as pd
import numpy as np

# data visualization
import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style='whitegrid', context='talk')

# machine learning
from sklearn.preprocessing import StandardScaler, RobustScaler
from sklearn.metrics import silhouette_score, calinski_harabasz_score, davies_bouldin_score #evaluation metrics
from sklearn.cluster import DBSCAN, KMeans
from sklearn.decomposition import PCA
from sklearn.model_selection import GridSearchCV

# remove warnings
import warnings;warnings.filterwarnings('ignore')

"""#### Loading Data"""

data = pd.read_csv('country-data.csv')
data.head()

"""#### Exploring Data"""

print(data.columns.tolist())

"""**Meaning of Columns in the dataset** <br>

1. 'country': This column contains the names of different countries, and it serves as a unique identifier for each country in the dataset.

2. 'child_mort': This column represents the child mortality rate, which is the number of child deaths per 1,000 live births in a given country. It is often used as an indicator of the overall health and well-being of a country's population.

3. 'exports': This column typically represents the percentage of a country's Gross Domestic Product (GDP) that comes from exports. It can be an important economic indicator, reflecting a country's reliance on international trade.

4. 'health': This column represents the percentage of a country's GDP spent on healthcare and public health expenditures. It is an indicator of the healthcare infrastructure and resources available in a country.

5. 'imports': Similar to 'exports,' this column represents the percentage of a country's GDP spent on imports. It reflects a country's dependence on foreign goods and services.

6. 'income': This column represents the per capita income or Gross National Income (GNI) of a country. It provides an estimate of the average income of the population, which is often used as a measure of the standard of living.

7. 'inflation': This column represents the annual inflation rate, which measures the percentage increase in the general price level of goods and services over a year. Inflation can have significant economic implications.

8. 'life_expec': This column represents the average life expectancy at birth for the population of a country. It is a key indicator of the overall health and well-being of a population.

9. 'total_fer': This column typically represents the Total Fertility Rate (TFR) in a country. TFR is the average number of children a woman is expected to have during her lifetime. It is an important demographic indicator.

10. 'gdpp': This column represents the Gross Domestic Product per capita (GDP per capita) for a country. It is a measure of the economic output per person and is often used to assess the economic well-being of a nation.
"""

# dimension of data
print(data.shape)
# summary of data
data.info()

"""#### Checking for missing values"""

# checking for missing values
missing_val = pd.concat([data.isnull().sum(), (data.isnull().mean() * 100).round(2)], axis=1, keys=['Total', 'Percentage of Missing Values (%)'])
missing_val = missing_val[missing_val['Total'] > 0].sort_values(by='Total', ascending=False)
print('Checking for null values in the dataset')
missing_val

"""As can be seen above, there are no missing values in the dataset."""

# Generate descriptive statistics
data.describe()

"""#### Feature Engineering
Engineering or creating new features from the previously existing features to enhance the performance of the model.
"""

# copy data to new variable, df
df = data.copy()

# economic dependency ratio
df['economic_dependency_ratio'] = df['exports'] / df['imports']

# Economic Development Level
income_bins = [0, 3355, 9960, 22800, float('inf')]
income_labels = ['Very Low', 'Low', 'Middle', 'High']
df['economic_development_level'] = pd.cut(df['income'], bins=income_bins, labels=income_labels)

# Ratio of Income to Health Spending
df['income_to_health_ratio'] = df['income'] / (df['health'] / 100)

# Life Expectancy Gap
df['life_expec_gap'] = df['life_expec'].max() - df['life_expec'].min()

# Inflation Category
inflation_bins = [-float('inf'), 1.81, 5.39, 10.75, float('inf')]
inflation_labels = ['Very Low', 'Low', 'Moderate', 'High']
df['inflation_category'] = pd.cut(df['inflation'], bins=inflation_bins, labels=inflation_labels)

"""**An explanation of the new columns engineered in the code above:** <br>

1. Economic Dependency Ratio: This is the ratio of exports to imports
2. Economic Development Level: This indicates the various levels of Income categorized into *Very Low*, *Low*, *Middle* and *High*
3. Income-to-Health-Ratio: This is the ratio of Income to Health
4. Life Expectancy Gap: This feature puts into consideration the difference between the difference between the maximum and minimum life expectancy at birth for the population of a country.
5. Inflation Category: This indicates the various levels of Inflation categorized into *Very Low*, *Low*, *Moderate* and *High*
"""

# random smaples of the data after adding new features
df.sample(10)

"""## Exploratory Data Analysis
In the Exploratory Data Analysis (EDA) section, the dataset will be investigated and its main features summarized. The primary goal of EDA is to help understand and summarize the contents of a dataset, typically with a specific question in mind, or to prepare for more advanced statistical modeling in future stages of data analysis
"""

# Setting Custom colors
my_colors = ["#ff6e54", "#ffa600", "#ff2e63", "#a3f7bf", "#9378ff", "#56e39f", "#ff67ab", "#5e2ca5", "#ffd166", "#00b4d8", "#4ecdc4", "#f8edeb"]

# Create a seaborn palette object
my_palette = sns.color_palette(my_colors)

# Use the custom palette with a seaborn function
sns.set_palette(my_palette)

from matplotlib.colors import ListedColormap
colors = ['#ffc3a0', '#ffafcc', '#a3f7bf', '#ffabab']
my_cmap = sns.color_palette(colors)
cmap = ListedColormap(colors)

# correlation between features
plt.figure(figsize=[20,10])
sns.heatmap(df.corr(numeric_only=True), annot=True, cmap=cmap, fmt='.2f').set(title='Correlation between Features')
plt.show;

"""In the heatmap above, it is observed that `child_mort` is strongly correlated with `gdpp`. Additionally, `exports` shows a strong connection with `imports` and a moderate relationship with `income`. Moreover, a notable relationship exists between `income` and `gdpp` as well as `life_expec`. The correlation between `life_expec` and `gdpp` is particularly strong, with a correlation coefficient of 0.61.

The level of correlation between these features suggests that there are significant connections between them. For example, a high positive correlation between 'child_mort' and 'gdpp' implies that lower GDP per capita tends to be associated with higher child mortality rates. Similarly, the strong correlation between 'income' and 'gdpp' indicates that higher income is linked to a higher GDP per capita.
"""

# distribution of features
for col in df.select_dtypes(include='number').columns:
    plt.figure(figsize=(13, 7))
    sns.histplot(x=col, data=df)
    plt.title(f'Distribution for {col}')
    plt.xlabel(col)
    plt.ylabel('Frequency')
    plt.show()

plt.figure(figsize=(10, 6))
sns.scatterplot(data=df, x='imports', y='exports').set(title='Distribution between Imports and Exports')
plt.show();

"""From this image,the above we can see that there is a positive correlation between imports and exports, meaning that as imports increase, exports also tend to increase. We can also see that there are a few outliers, which may suggest that there are some countries that have a higher or lower level of imports and exports than the majority of countries."""

plt.figure(figsize=(10, 6))
sns.scatterplot(data=df, x='income', y='gdpp').set(title='Distribution between Income and GDPP')
plt.show();

"""There is a positive correlation between income and GDPP. This means that as income increases, GDPP also tends to increase."""

plt.figure(figsize=(10, 6))
sns.scatterplot(data=df, x='child_mort', y='life_expec').set(title='Distribution between Life Expectancy and Child Mortality')
plt.show();

"""The dots are clustered towards the top left of the plot, indicating a negative correlation between the two variables. Specifically, it appears that there is a negative correlation between life expectancy and child mortality, meaning that as child mortality decreases, life expectancy increases."""

plt.figure(figsize=(10, 6))
sns.scatterplot(data=df, x='total_fer', y='child_mort').set(title='Distribution between Total Fertility Rate (TFR) and Child Mortality')
plt.show();

"""The insights that can be gained from the above is that there is a positive correlation between Total Fertility Rate (TFR) and Child Mortality. This means that as TFR increases, so does Child Mortality."""

# Distribution of Economic Development Level
count_data = df['economic_development_level'].value_counts()
total_count = len(df)

plt.figure(figsize=(10, 6))
plt.pie(count_data, labels=count_data.index, autopct=lambda p: f'{int(p * total_count / 100)}\n({p:.1f}%)', startangle=90, pctdistance=0.85,
        wedgeprops={'width': 0.4, 'edgecolor': 'w'})

centre_circle = plt.Circle((0, 0), 0.70, fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)

plt.title('Distribution of Economic Development Level')
plt.axis('equal')
plt.show()

# Distribution of inflation category
count_data = df['inflation_category'].value_counts()
total_count = len(df)

plt.figure(figsize=(10, 6))
plt.pie(count_data, labels=count_data.index, autopct=lambda p: f'{int(p * total_count / 100)}\n({p:.1f}%)', startangle=90, pctdistance=0.85,
        wedgeprops={'width': 0.4, 'edgecolor': 'w'})

centre_circle = plt.Circle((0, 0), 0.70, fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)

plt.title('Distribution of Inflation Category')
plt.axis('equal')
plt.show()

"""#### Encoding categorical features and Scaling the data
Scaling/Standardizing the features ensures that all features have the same scale, which can make it easier for the model to learn the relationships between them. The StandardScaler() function will be used to achieve this.
"""

cols = ['economic_development_level', 'inflation_category']
for col in cols:
    print(df[col].unique())

# encode the categorical features and scale the dataset
cols = ['economic_development_level', 'inflation_category']
for col in cols:
    df[col] = df[col].cat.codes
for col in cols:
    print(df[col].unique())


scaler = StandardScaler()
df = df.drop(['country'], axis=1)
scaled_data = scaler.fit_transform(df)
df_scaled = pd.DataFrame(scaled_data, columns=df.columns)
df_scaled.head()

"""## Building the Clustering Algorithms to Segment the Data

Here, different clustering algorithms and Evaluation metrics will be explored to try to choose the optimal number of clusters for the dataset.

### DBSCAN: Density-Based Clustering

[DBSCAN (Density-Based Spatial Clustering of Applications with Noise)](https://ai.plainenglish.io/dbscan-density-based-clustering-aaebd76e2c8c) is a widely used density-based clustering algorithm. It groups together points that are closely packed together (points with many adjacent neighbors), while filtering out noise points that lie in low-density regions.
"""

# scaling data using StandardScaler
scaler = StandardScaler()
scaled_data = scaler.fit_transform(df)
df_scaled = pd.DataFrame(scaled_data, columns=df.columns)
df_scaled.head()

"""Choosing the best values for the below parameters
- Epsilon (ϵ): The radius of the neighborhood around a data point.
- MinPts (Minimum Points): The minimum number of data points required to be within the ϵ-radius of a given point.
"""

# Define a range of eps and min_samples values to search
param_grid = {
    'eps': [0.5, 1.0, 1.5, 2.0],
    'min_samples': [2, 3, 4, 5]
}

# Create the DBSCAN model
dbscan = DBSCAN()

# Define scoring functions for Silhouette Score and Davies-Bouldin Index
def silhouette_scorer(estimator, X):
    cluster_labels = estimator.fit_predict(X)
    if len(set(cluster_labels)) > 1:
        return silhouette_score(X, cluster_labels)
    return -1  # Return a negative value if only one cluster is found

def davies_bouldin_scorer(estimator, X):
    cluster_labels = estimator.fit_predict(X)
    if len(set(cluster_labels)) > 1:
        return davies_bouldin_score(X, cluster_labels)
    return np.inf  # Return a large value if only one cluster is found

# Perform grid search with Silhouette Score as the scoring metric
grid_search = GridSearchCV(
    dbscan,
    param_grid,
    cv=5,
    scoring={'Silhouette Score': silhouette_scorer, 'Davies-Bouldin Index': davies_bouldin_scorer},
    refit='Silhouette Score'
)
grid_search.fit(df_scaled)

# Get the best combination of parameters
best_eps = grid_search.best_params_['eps']
best_min_samples = grid_search.best_params_['min_samples']

"""**Fitting data with the best parameters** <br>
dbscan = DBSCAN(eps=best_eps, min_samples=best_min_samples)<br>
dbscan.fit(df_scale)<br>
"""

# Fit DBSCAN with the best parameters
best_dbscan = DBSCAN(eps=best_eps, min_samples=best_min_samples)
cluster_labels = best_dbscan.fit_predict(df_scaled)

# Get the number of clusters (excluding noise points)
num_clusters = len(set(cluster_labels)) - (1 if -1 in cluster_labels else 0)

# Get the number of noise points (outliers)
num_noise_points = list(cluster_labels).count(-1)

# Print the best parameters and results
print(f"Best eps: {best_eps}")
print(f"Best min_samples: {best_min_samples}")
print(f"Number of Clusters: {num_clusters}")
print(f"Number of Noise Points (Outliers): {num_noise_points}")

print('Corresponding Davies-Bouldin Index: ', davies_bouldin_score(df_scaled, cluster_labels))
print('Best Silhouette Score:', silhouette_score(df_scaled, cluster_labels))

np.unique(cluster_labels, return_counts=True)

def plot_dbscan_clusters(data, cluster_labels, my_colors):
    unique_labels = np.unique(cluster_labels)
    n_clusters = len(unique_labels) - 1  # Exclude noise points (-1)

    plt.figure(figsize=(10, 6))
    for cluster_label in unique_labels:
        if cluster_label == -1:
            color = 'black'
            legend_label = 'Noise'
        else:
            color = my_colors[cluster_label]
            legend_label = f'Cluster {cluster_label}'

        # Extract data points belonging to the current cluster label
        cluster_data = data[cluster_labels == cluster_label]
        plt.scatter(cluster_data[:, 0], cluster_data[:, 1], c=color, label=legend_label)

    plt.title(f'DBSCAN Clustering (Number of Clusters: {n_clusters})')
    plt.legend()
    plt.show()

plot_dbscan_clusters(df_scaled.values, cluster_labels, my_colors)

"""### Cluster Profiling
This involves the profiling of the segments by studying the patterns of the clusters.
"""

df['clusters_db'] = cluster_labels

plt.figure(figsize=(10, 6))
ax = sns.countplot(x=df["clusters_db"], color=my_colors[0])
ax.set_title("Distribution Of The Clusters")
ax.bar_label(ax.containers[0], fmt='%.0f', label_type='edge')
plt.show();

# Define custom colors for the clusters
clusters_palette = {
    -1: '#000000',
    0: '#FF0000',
    1: '#00FF00',
    2: '#0000FF',
    3: '#FFFF00'
}

plt.figure(figsize=(20, 20))
sns.scatterplot(data=df, x='income', y='gdpp', hue='clusters_db', palette=clusters_palette)
plt.title('Distribution between Income and GDPP')
plt.xlabel('Income')
plt.ylabel('GDPP')
plt.legend()
plt.show()

"""**Insights** <br><br>
Outliers (Black): This are points in Cluster -1 which are data points that do not align with any specific cluster. These outliers exhibit extreme income or GDPP values compared to the rest of the dataset. They could represent regions with unique circumstances or characteristics impacting their income and GDPP, such as political instability, conflict, sanctions, or other factors.

Cluster 0 (Red): This cluster comprises countries or regions with the lowest income and GDPP among the clusters. These areas may be characterized as underdeveloped or economically challenged, with limited economic output and growth.

Cluster 1 (Green): Cluster 1 exhibits low income but relatively high GDPP. It may represent areas with a small population but a substantial economic output per person, or those receiving substantial foreign aid or investment.

Cluster 2 (Blue): Cluster 2 showcases high income and high GDPP, signifying developed or affluent countries or regions with substantial economic output and growth.

Cluster 3 (Yellow): This cluster portrays regions with low income but low GDPP. It signifies underdevelopment in a country.
"""

plt.figure(figsize=(20, 20))
sns.scatterplot(data=df, x='imports', y='exports', hue='clusters_db', palette=clusters_palette)
plt.title('Distribution between Imports and Exports')
plt.xlabel('Imports')
plt.ylabel('Exports')
plt.legend()
plt.show()

"""**Insights** <br><br>
The plot reveals a noticeable positive correlation between imports and exports. As imports increase, exports tend to increase as well. This correlation is observed through the general trend of data points clustering in the direction from the bottom-left to the top-right of the plot. It suggests that countries or regions with higher imports also tend to have higher export levels, indicating active trade relationships.

Outliers (Black): The presence of black data points identifies outliers—data points that deviate significantly from the general trend. These outliers may represent countries or regions with unique trade dynamics or trade patterns influenced by external factors.

Red Cluster (Cluster 0): The majority of data points fall within the red cluster, signifying countries or regions with relatively balanced trade, where imports and exports are proportional. This cluster represents the standard trade pattern.

Green Cluster (Cluster 1): The green cluster, on the other hand,  indicates countries having a higher level of export with a relatively high level of imports too.

Blue Cluster (Cluster 2): The blue clusters includes data points that dont deviate really much from the red indicating that countries like this too have a relatively balanced trade level.

Yellow Cluster (Cluster 3): The yellow cluster is another outlier, characterized by very low export rate and a high import rate too. These may indicate countries in this clusters are highly dependent on foreign goods and services.
"""

plt.figure(figsize=(20, 20))
sns.scatterplot(data=df, x='child_mort', y='life_expec', hue='clusters_db', palette=clusters_palette)
plt.title('Distribution between Life Expectancy and Child Mortality')
plt.xlabel('Life Expectancy')
plt.ylabel('Child Mortality')
plt.legend()
plt.show()

"""**Insights** <br><br>
 The plot distinctly illustrates a negative correlation between Life Expectancy and Child Mortality. As Life Expectancy increases, Child Mortality rates tend to decrease. This trend underscores the importance of improving healthcare and living conditions, as higher life expectancy is often associated with lower child mortality.

Outliers (Black): The presence of black data points on the plot draws attention to outliers—data points that significantly deviate from the general trend. These outliers may represent countries or regions with unique or unusual living dynamics, warranting further investigation to understand the factors contributing to their distinct health patterns.

Red Cluster (Cluster 0):  The majority of data points cluster within the red cluster, indicating countries with relatively balanced child mortality rates and life expectancy. This cluster represents regions where healthcare and living conditions are harmonized, resulting in favorable life expectancies and lower child mortality rates. It serves as a benchmark for the standard health and well-being profile.

Green Cluster (Cluster 1): The green cluster, on the other hand,  indicates countries having a high child mortality rate and a high life expectancy too. This cluster may suggest unique circumstances where healthcare interventions have led to extended life expectancies despite ongoing child mortality challenges.

Blue Cluster (Cluster 2): The presence of countries within the blue cluster reflects a distressing scenario. These countries exhibit exceptionally high child mortality rates and extremely low life expectancies. This cluster signals a critical need for urgent healthcare and social interventions to address the alarming health disparities.

Yellow Cluster (Cluster 3): The yellow cluster is characterized by high child mortatlity rates and a relatively low life expectancy. This scenario points to regions where healthcare and living conditions may be lagging behind, resulting in comparatively lower life expectancies and higher child mortality rates.
"""

plt.figure(figsize=(20, 20))
sns.boxplot(data=df, x='clusters_db', y='income', palette=clusters_palette)
plt.title('Income Rates by Cluster')
plt.xlabel('Cluster')
plt.ylabel('Income')
plt.show()

"""**Insights** <br><br>
The box plot offers insights into income rates categorized by clusters. Each cluster is color-coded: the black box signifies outliers, the red box corresponds to cluster 0, the green box represents cluster 1, the blue box symbolizes cluster 2, and the yellow box portrays cluster 3.

Outliers' Income Profile: The outliers, depicted in black, represent data points with income rates significantly deviating from the norm. Notably, they display the lowest median income among all clusters and possess the most restricted income range. These outliers may represent unique cases or exceptional economic conditions within the dataset.

Median Income Ranking: Cluster 2 stands out with the highest median income, positioning it as the most economically prosperous group. It is followed by cluster -1, cluster 0, and cluster 3 in descending order of median income. This ranking reveals a distinct disparity in income distribution among the clusters. lower life expectancies and higher child mortality rates.

Income Range Variation: When considering the spread of income rates within each cluster, cluster 2 exhibits the broadest range, indicating a considerable diversity of income levels within this group. Following cluster 2, cluster -1 and cluster 0 also showcase notable income variability. In contrast, cluster 1 demonstrates a relatively narrower income range compared to the other clusters.

## Conclusion

In this project, we applied DBSCAN as our clustering algorithm to analyze a dataset encompassing various socio-economic factors. The results revealed significant insights into different clusters and their characteristics. <br><br>

**Highlights** <br><br>
*Cluster Analysis*
The dataset was segmented into distinct clusters, including outliers denoted by black data points in Cluster -1. These outliers represented regions facing unique circumstances, possibly due to political instability, conflict, or sanctions. Cluster 0 (Red) included countries with the lowest income and GDPP, signaling underdevelopment. Cluster 1 (Green) depicted regions with low income yet relatively high GDPP, possibly due to foreign aid or efficient economic output. Cluster 2 (Blue) comprised economically prosperous countries with high income and GDPP. Cluster 3 (Yellow) represented areas with low income and low GDPP, indicating underdevelopment.

*Trade Analysis*
An examination of trade relationships unveiled a notable positive correlation between imports and exports, highlighting active trade patterns. Outliers in black represented data points with unique trade dynamics, influenced by external factors. Cluster 0 (Red) featured balanced trade with proportional imports and exports. Cluster 1 (Green) showcased higher exports and relatively high imports, suggesting active trade engagement. Cluster 2 (Blue) reflected balanced trade patterns, not deviating significantly from the standard. Cluster 3 (Yellow) exhibited a high level of imports and very low export rates, implying a reliance on foreign goods and services.

*Health Analysis*
The analysis of health-related factors revealed a clear negative correlation between Life Expectancy and Child Mortality, emphasizing the significance of healthcare and living conditions. Black outliers were indicative of regions with unique or unusual living dynamics. Cluster 0 (Red) encompassed areas with balanced child mortality rates and life expectancy, portraying harmonized health and well-being. Cluster 1 (Green) represented unique circumstances where healthcare interventions led to extended life expectancies despite high child mortality rates. Cluster 2 (Blue) depicted a distressing scenario with extremely high child mortality rates and very low life expectancies, urging immediate healthcare and social interventions. Cluster 3 (Yellow) signified regions with lagging healthcare and living conditions, resulting in comparatively lower life expectancies and higher child mortality rates.

*Income Analysis*
A comprehensive examination of income rates through box plots exposed intriguing disparities. Black outliers featured significantly deviating income rates, with the lowest median income and the narrowest income range, potentially indicating unique economic conditions. Cluster 2 held the highest median income, followed by Cluster -1, Cluster 0, and Cluster 3. This ranking underscored stark disparities in income distribution. Cluster 2 demonstrated the broadest income range, with Clusters -1 and 0 also showing significant income variability. Cluster 1, in contrast, displayed a relatively narrower income range. <br><br>

**Further Improvements** <br><br>
To enhance the analysis, several potential improvements can be implemented. Further feature engineering could help in creating more relevant variables or combining existing ones for a more comprehensive perspective. Additionally, the integration of additional clustering algorithms including KMeans, Agglomerative Clustering algorithms could provide more robust results. Furthermore, incorporating geographical and geopolitical factors may offer a deeper understanding of the dataset. Lastly, advanced visualization techniques and interactive dashboards can make the results more accessible and insightful for stakeholders.
"""

